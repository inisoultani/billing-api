// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: schedules.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLoanSchedule = `-- name: CreateLoanSchedule :one
INSERT INTO schedules (
    loan_id,
    sequence,
    due_date,
    amount,
    status
  )
VALUES ($1, $2, $3, $4, 'PENDING')
RETURNING id, loan_id, sequence, due_date, amount, paid_amount, status, created_at, updated_at
`

type CreateLoanScheduleParams struct {
	LoanID   int64
	Sequence int32
	DueDate  pgtype.Date
	Amount   int64
}

func (q *Queries) CreateLoanSchedule(ctx context.Context, arg CreateLoanScheduleParams) (Schedule, error) {
	row := q.db.QueryRow(ctx, createLoanSchedule,
		arg.LoanID,
		arg.Sequence,
		arg.DueDate,
		arg.Amount,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.LoanID,
		&i.Sequence,
		&i.DueDate,
		&i.Amount,
		&i.PaidAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getScheduleBySequence = `-- name: GetScheduleBySequence :one
SELECT id, loan_id, sequence, due_date, amount, paid_amount, status, created_at, updated_at
FROM schedules
WHERE loan_id = $1
  AND sequence = $2
LIMIT 1
`

type GetScheduleBySequenceParams struct {
	LoanID   int64
	Sequence int32
}

func (q *Queries) GetScheduleBySequence(ctx context.Context, arg GetScheduleBySequenceParams) (Schedule, error) {
	row := q.db.QueryRow(ctx, getScheduleBySequence, arg.LoanID, arg.Sequence)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.LoanID,
		&i.Sequence,
		&i.DueDate,
		&i.Amount,
		&i.PaidAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSchedulesByLoanIDWithCursor = `-- name: ListSchedulesByLoanIDWithCursor :many
SELECT id, loan_id, sequence, due_date, amount, paid_amount, status, created_at, updated_at
FROM schedules
WHERE loan_id = $1
  AND sequence > $2
ORDER BY sequence
LIMIT $3
`

type ListSchedulesByLoanIDWithCursorParams struct {
	LoanID   int64
	Sequence int32
	Limit    int32
}

func (q *Queries) ListSchedulesByLoanIDWithCursor(ctx context.Context, arg ListSchedulesByLoanIDWithCursorParams) ([]Schedule, error) {
	rows, err := q.db.Query(ctx, listSchedulesByLoanIDWithCursor, arg.LoanID, arg.Sequence, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Schedule
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.LoanID,
			&i.Sequence,
			&i.DueDate,
			&i.Amount,
			&i.PaidAmount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSchedulePayment = `-- name: UpdateSchedulePayment :one
UPDATE schedules
SET paid_amount = paid_amount + $2,
  status = CASE
    WHEN paid_amount + $2 >= amount THEN 'PAID'
    ELSE 'PARTIAL'
  END,
  updated_at = now()
WHERE id = $1
RETURNING id, loan_id, sequence, due_date, amount, paid_amount, status, created_at, updated_at
`

type UpdateSchedulePaymentParams struct {
	ID         int64
	PaidAmount int64
}

func (q *Queries) UpdateSchedulePayment(ctx context.Context, arg UpdateSchedulePaymentParams) (Schedule, error) {
	row := q.db.QueryRow(ctx, updateSchedulePayment, arg.ID, arg.PaidAmount)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.LoanID,
		&i.Sequence,
		&i.DueDate,
		&i.Amount,
		&i.PaidAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
